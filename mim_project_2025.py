# -*- coding: utf-8 -*-
"""MIM_project_2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ii89moG8kJDwrqWs1MDeMPMOJJvzw18W

## Workspace Setup
"""

# @title
import numpy as np
from scipy import signal

import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go

import os
try:
    import google.colab
    IN_COLAB = True
except:
    IN_COLAB = False

if not IN_COLAB:
  os.chdir('/scratch_hdd/akalinow/ELITPC/MIM_project_2025')
else:
  !wget -O dEdx_corr_alpha_10MeV_CO2_250mbar.dat --no-check-certificate -r 'https://drive.google.com/uc?export=download&id=1RyPeiZg0tXeNrGZfqa6Ms9BhPvvURUR4'
  !wget -O dEdx_corr_12C_5MeV_CO2_250mbar.dat --no-check-certificate -r 'https://drive.google.com/uc?export=download&id=1jD461vd6x1dpATYZuqZTl0eW6bnc3_di'

# @title
projectionPhis = {
    "U": 0.0,
    "V": np.pi/6.0,
    "W": -np.pi/6.0
}
##############################################
##############################################
carbon_Bragg = np.loadtxt("./dEdx_corr_12C_5MeV_CO2_250mbar.dat")
alpha_Bragg = np.loadtxt("./dEdx_corr_alpha_10MeV_CO2_250mbar.dat")

print("Total energy loss (12C)   : {:.3f} MeV".format(np.sum(carbon_Bragg[:,1]*0.25)/1000.0))
print("Total energy loss (alpha): {:.3f} MeV".format(np.sum(alpha_Bragg[:,1]*1.0)/1000.0))
##############################################
##############################################
def getLineIn3D(vertex=(0,0,0), carbonLength=5.0, alphaLength=40.0):

    angles = np.random.default_rng().uniform(0,1,(2))
    angles *= (2*np.pi, 2.0)
    angles += (0, -1)
    angles[1] = np.arccos(angles[1])

    rho = 1.0
    tangent = np.array([rho*np.sin(angles[1])*np.cos(angles[0]),
                        rho*np.sin(angles[1])*np.sin(angles[0]),
                        rho*np.cos(angles[1])])

    nPoints = 1024
    delta = np.linspace(-carbonLength,alphaLength,nPoints)
    delta = np.expand_dims(delta, axis=1)
    line = vertex + delta*tangent
    return line
##############################################
##############################################
def smearLine(line, sigma=1.0):

    noise = np.random.default_rng().normal(0,sigma,line.shape)
    noise[0,:] = 0.0 #do not smear endpoints to keep POIs exact for plotting
    noise[-1,:] = 0.0 #do not smear endpoints to keep POIs exact for plotting
    smearedLine = line + noise
    return smearedLine

###############################################
###############################################
def plot3DLine(line):

    ax = plt.subplot(111, projection='3d')
    ax.plot(line[:,0], line[:,1], line[:,2], 'b-')
    ax.axes.set_xlim3d(left=-100, right=100)
    ax.axes.set_ylim3d(bottom=-100, top=100)
    ax.axes.set_zlim3d(bottom=-100, top=100)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    return ax
##############################################
##############################################
def plot3DLinePlotly(line, density=None, projection="V"):

    # make interactive plot with plotly
    if density is not None:
        density = density.flatten()

    fig = px.scatter_3d(x=line[:,0], y=line[:,1], z=line[:,2],
                        color=density, size=density, size_max=50)

    ##add projection
    phi = projectionPhis[projection]
    normal = np.array([np.cos(phi), -np.sin(phi), 0])
    point = np.array([-100,0,0])
    phi = np.arctan2(normal[1], normal[0])
    xx, zz = np.meshgrid(range(-100,100,1), range(-100,100,1))
    yy =  (xx - point[0])*np.tan(phi) + point[1]

    if projection in ["U","V","W"]:
        fig.add_trace(
            go.Scatter3d(
                x=xx.flatten(),
                y=yy.flatten(),
                z=zz.flatten(),
                opacity=0.3,
                mode='lines',
                line=dict(color='black', width=2),
                name=projection + 'T plane'
            )
        )

    # set axes limits
    fig.update_layout(scene = dict(
                        xaxis = dict(nticks=10, range=[-100,100],),
                        yaxis = dict(nticks=10, range=[-100,100],),
                        zaxis = dict(nticks=10, range=[-100,100],),),
                        width=700, height=500,
                        margin=dict(r=20, b=10, l=10, t=10))


    fig.show()
###############################################
##############################################
def plot3DPlane(normal, point, ax):

    phi = np.arctan2(normal[1], normal[0])
    xx, zz = np.meshgrid(range(-100,100,10), range(-100,100,10))
    yy =  (xx - point[0])*np.tan(phi) + point[1]
    ax.plot_surface(xx, yy, zz, alpha=0.5)
    return ax
##############################################
##############################################
def plot3DPOIs(vertex, line, ax):

    ax.scatter(vertex[0], vertex[1], vertex[2], c='r', marker='o')
    ax.scatter(line[0,0], line[0,1], line[0,2], c='r', marker='o')
    ax.scatter(line[-1,0], line[-1,1], line[-1,2], c='r', marker='o')
    return ax
##############################################
##############################################
def getXYZtoUVWT(data):

    referencePoint = np.array([-138.9971, 98.25]) # mm
    stripPitch = 1.5
    samplingFrequency = 25.0 # MHz
    driftVelocity = 6.46 # mm/us 4.05
    f = 1.0/samplingFrequency*driftVelocity
    triggerDelay = 5 #time bins
    u = -(data[:,1]-99.75) # change direction of the axis
    v = (data[:,0]-referencePoint[0])*np.cos(projectionPhis["V"]) - (data[:,1]-referencePoint[1])*np.sin(projectionPhis["V"]) + 98.75
    w = (data[:,0]-referencePoint[0])*np.cos(-projectionPhis["W"]) - (data[:,1]-referencePoint[1])*np.sin(-projectionPhis["W"]) + 98.75
    t = data[:,2]/f + 256 + triggerDelay
    u/=stripPitch
    v/=stripPitch
    w/=stripPitch

    return np.stack((u,v,w,t), axis=1)
##############################################
##############################################
def plotUVWT(lineUVWT, density=None, zoom=False):

    if density is None:
        density = np.ones(lineUVWT.shape[0])

    fig, axes = plt.subplots(1,3, figsize=(15,5), constrained_layout=True)
    axes[0].hist2d(lineUVWT[:,3], lineUVWT[:,0], bins=(512,256), range=[[0,512],[0,256]], cmap='jet', weights=density, cmin=0.1)
    axes[0].set_ylabel('U [strip number]')
    axes[0].set_xlabel('T [time bin]')
    axes[0].set_title('U vs T')
    axes[0].grid()

    axes[1].hist2d(lineUVWT[:,3], lineUVWT[:,1], bins=(512,256), range=[[0,512],[0,256]], cmap='jet', weights=density, cmin=0.1)
    axes[1].set_ylabel('V [strip number]')
    axes[1].set_xlabel('T [time bin]')
    axes[1].set_title('V vs T')
    axes[1].grid()

    axes[2].hist2d(lineUVWT[:,3], lineUVWT[:,2], bins=(512,256), range=[[0,512],[0,256]], cmap='jet', weights=density, cmin=0.1)
    axes[2].set_ylabel('W [strip number]')
    axes[2].set_xlabel('T [time bin]')
    axes[2].set_title('W vs T')
    axes[2].grid()

    if zoom:
        axes[0].set_xlim(np.min(lineUVWT[:,3]), np.max(lineUVWT[:,3]))
        axes[0].set_ylim(np.min(lineUVWT[:,0]), np.max(lineUVWT[:,0]))
        axes[1].set_xlim(np.min(lineUVWT[:,3]), np.max(lineUVWT[:,3]))
        axes[1].set_ylim(np.min(lineUVWT[:,1]), np.max(lineUVWT[:,1]))
        axes[2].set_xlim(np.min(lineUVWT[:,3]), np.max(lineUVWT[:,3]))
        axes[2].set_ylim(np.min(lineUVWT[:,2]), np.max(lineUVWT[:,2]))

    return fig, axes
##############################################
##############################################
def getSmearedBragg(curve, windowSize, sigma, lengthScale=1.0):

    window = signal.windows.gaussian(windowSize, std=sigma/lengthScale)
    window/=np.sum(window)
    curve_smeared = signal.convolve(curve[:,1], window, mode='full')
    x = np.arange(-windowSize/2, curve.shape[0]+windowSize/2-1)
    curve_smeared = np.stack((x*lengthScale, curve_smeared), axis=1)
    curve_smeared = curve_smeared[:-windowSize//2  :]
    return curve_smeared
##############################################
##############################################
def getBraggForTrack(trackData, vertex, sigma=2.0, windowSize=50):

    carbonTrackLength = np.sqrt(np.sum((trackData[0:1,:] - vertex)**2, axis=1))[0]
    carbon_Bragg_start = int(carbon_Bragg[-1,0] - carbonTrackLength)*4 # Carbon Bragg is sampled every 0.25 mm
    carbon_Bragg_smeared = getSmearedBragg(carbon_Bragg[carbon_Bragg_start:], windowSize, sigma, lengthScale=0.25)
    carbon_Bragg_smeared[:,0] *= -1
    indices = np.argsort(carbon_Bragg_smeared[:,0])
    carbon_Bragg_smeared = carbon_Bragg_smeared[indices]

    alphaTrackLength = np.sqrt(np.sum((trackData[-2:-1,:] - vertex)**2, axis=1))[0]
    alpha_Bragg_start =  int(alpha_Bragg[-1,0]  - alphaTrackLength)  # Alpha Bragg is sampled every 1 mm
    alpha_Bragg_smeared = getSmearedBragg(alpha_Bragg[alpha_Bragg_start:], windowSize, sigma, lengthScale=1.0)

    #print("Total energy loss smeared (12C)   : {:.3f} MeV".format(np.sum(carbon_Bragg_smeared[:,1]*0.25)/1000.0))
    #print("Total energy loss smeared (alpha) : {:.3f} MeV".format(np.sum(alpha_Bragg_smeared[:,1]*1.0)/1000.0))

    carbon_Bragg_smeared[:,0] += carbonTrackLength
    alpha_Bragg_smeared[:,0] += carbonTrackLength

    step = 0.25
    x = np.arange(0, carbonTrackLength+alphaTrackLength+windowSize*step, step)
    y = np.interp(x, carbon_Bragg_smeared[:,0], carbon_Bragg_smeared[:,1], left=0, right=0) + np.interp(x, alpha_Bragg_smeared[:,0], alpha_Bragg_smeared[:,1], left=0, right=0)
    track_Bragg = np.stack((x, y), axis=1)

    return carbon_Bragg_smeared, alpha_Bragg_smeared, track_Bragg
##############################################
##############################################
def plotPOI(poiUVWT, axes, color='r'):

    axes[0].scatter(poiUVWT[0,3], poiUVWT[0,0], c=color, marker='o', s=100, alpha=0.7)
    axes[1].scatter(poiUVWT[0,3], poiUVWT[0,1], c=color, marker='o', s=100, alpha=0.7)
    axes[2].scatter(poiUVWT[0,3], poiUVWT[0,2], c=color, marker='o', s=100, alpha=0.7)

##############################################
##############################################
def getNoiseUVWT(mu=0, sigma=20):

    noisePoints = 1024
    noiseVal = np.random.default_rng().normal(mu,sigma,(noisePoints,3))
    noisePos = np.random.default_rng().uniform(0,256,(noisePoints,4))
    noisePos[:,3] *= 2

    return noisePos, noiseVal
##############################################
##############################################
def makePlotSet(lineXYZ, vertex, sigma=0, density=None, zoom=False, noise=False):
    ax = plot3DLine(lineXYZ)
    ax = plot3DPOIs(vertex, lineXYZ, ax)

    for phi in projectionPhis.values():
        ax = plot3DPlane(np.array((np.cos(phi), np.sin(phi),0)), np.array((0,0,0)), ax)

    lineUVWT = getXYZtoUVWT(lineXYZ)
    noiseUVWT, noiseVal = getNoiseUVWT(mu=0, sigma=15.0)

    if density is not None and noise:
        lineUVWT = np.concatenate((lineUVWT, noiseUVWT), axis=0)
        density = np.concatenate((density, noiseVal[:,0]), axis=0)

    fig, axes = plotUVWT(lineUVWT, density=density, zoom=zoom)

    vertexUVWT = getXYZtoUVWT( np.expand_dims(vertex, axis=0) )
    plotPOI(vertexUVWT, axes, color='r')
    startUVWT = getXYZtoUVWT( np.expand_dims(lineXYZ[0,:], axis=0) )
    plotPOI(startUVWT, axes, color='r')
    endUVWT = getXYZtoUVWT( np.expand_dims(lineXYZ[-1,:], axis=0) )
    plotPOI(endUVWT, axes, color='r')


"""#my adition:

# 1. Run your simulation
makePlotSet(lineXYZ, vertex, density=density, zoom=True, noise=True)

# 2. NOW load the projections for denoising
fig, axes = plotUVWT(getXYZtoUVWT(lineXYZ), density=density, zoom=True)

image_UT = axes[0].images[0].get_array()
image_VW = axes[1].images[0].get_array()
image_WT = axes[2].images[0].get_array()

from noise_removal import compare_methods

results_UT = compare_methods(image_UT)
results_VW = compare_methods(image_VW)
results_WT = compare_methods(image_WT)
"""

##########################################################################
##########################################################################
def makeBraggPlots(carbon_Bragg_smeared, alpha_Bragg_smeared, track_Bragg):

    # plot data
    fig, axes = plt.subplots(1,3, figsize=(12,3), constrained_layout=True)
    axes[0].plot(carbon_Bragg[:,0], carbon_Bragg[:,1], 'b-')
    axes[0].plot(carbon_Bragg_smeared[:,0], carbon_Bragg_smeared[:,1], 'g-')
    axes[0].set_xlabel('Distance along track [mm]')
    axes[0].set_ylabel('dE/dx [keV/mm]')
    axes[0].legend(['Bragg','smeared'])
    axes[0].grid()

    axes[1].plot(alpha_Bragg[:,0], alpha_Bragg[:,1], 'b-')
    axes[1].plot(alpha_Bragg_smeared[:,0], alpha_Bragg_smeared[:,1], 'g-')
    axes[1].set_xlabel('Distance along track [mm]')
    axes[1].set_ylabel('dE/dx [keV/mm]')
    axes[1].legend(['Bragg','smeared'])
    axes[1].grid()

    axes[2].plot(carbon_Bragg_smeared[:,0], carbon_Bragg_smeared[:,1], 'r-', label=r'${}^{12}$C')
    axes[2].plot(alpha_Bragg_smeared[:,0], alpha_Bragg_smeared[:,1], 'b-', label=r'$\alpha$')
    axes[2].plot(track_Bragg[:,0], track_Bragg[:,1], 'g-', label=r'${}^{12}$C + $\alpha$')
    axes[2].set_xlabel('Distance along track [mm]')
    axes[2].set_ylabel('dE/dx [keV/mm]')
    axes[2].legend()
    axes[2].grid()
    #######################################################
    #######################################################
def getBraggDensity(line, track_Bragg, sigma=2.0):

    x_along_line = np.sqrt(np.sum((line - line[0,:])**2, axis=1))
    x_along_line = np.where(x_along_line<len(track_Bragg), x_along_line,0)
    mu = np.interp( x_along_line, track_Bragg[:,0], track_Bragg[:,1], left=0, right=0 )

    density = np.random.default_rng().normal(mu, sigma)
    density = np.where(density>0, density, 0)
    density *= 50/np.max(density)
    return density
##############################################
##############################################

"""# The task:
### an inverse problem: easy to simulate, hard to solve:

$$
\huge{
\begin{align*}
f(x) &= y \text{ - easy to compute}\\
f^{-1}(y) &= x \text{ - hard to compute, or even not unique}
\end{align*}
}
$$

# Input, `y`:
###  images with shape `256x512x3`

# Output, `x`:
## 3D coordinates of three points of interest (POI):

$$
\huge{
(x_1, y_1, z_1), (x_2, y_2, z_2), (x_3, y_3, z_3)
}
$$

### Stage 0:
## Input represents an ideal line in three, non orthogonal, projections.

The middle POI is not defined. Other POIs represent line endpoints.
"""

vertex = np.array((0,0,0))
carbonLength = 15.0
alphaLength = 60.0
lineXYZ = getLineIn3D(vertex, carbonLength, alphaLength)

plot3DLinePlotly(lineXYZ)

makePlotSet(lineXYZ, vertex)

"""### Stage 1:
## Input represents a smeared line.
The edges of the line are fuzzy.
"""

sigma = 2.0
lineXYZ = smearLine(lineXYZ, sigma=sigma)

plot3DLinePlotly(lineXYZ)

makePlotSet(lineXYZ, vertex)

"""### Step 3:
## Input represents a smeared line with non uniform pixel values along the line
The middle POI (`vertex`) is defined as the stitching point between two, **smeared** distributions.
"""

carbon_Bragg_smeared, alpha_Bragg_smeared, track_Bragg = getBraggForTrack(lineXYZ, vertex, sigma=sigma, windowSize=50)
carbon_Bragg, alpha_Bragg, _ = getBraggForTrack(lineXYZ, vertex, sigma=0.02, windowSize=50)
density = getBraggDensity(lineXYZ, track_Bragg, sigma=sigma)
makeBraggPlots(carbon_Bragg_smeared, alpha_Bragg_smeared, track_Bragg)

plot3DLinePlotly(lineXYZ[::10], density[::10])

makePlotSet(lineXYZ=lineXYZ, vertex=vertex, density=density, zoom=True)

"""### Step 4:
## Input represents a smeared line with non uniform pixel values along the line on the random noise background.

"""

makePlotSet(lineXYZ=lineXYZ, vertex=vertex, density=density, zoom=True, noise=True)

"""### The story behind:

The line in 3D is a track of ions: alpha particle (He nucleus) and carbon nucleus (C ion) created in photodisintegration of oxygen nucleus:
$$
\huge{
 \gamma + {}^{16}O  \rightarrow \alpha + {}^{12}C
}
$$

The POIs are:
- the position of the $\gamma + {}^{16}O$ collision: vertex
- the end point of the alpha particle track
- the end point of the carbon nucleus track

Images in the UT, VW and WT projections represents the data collected by the detector: WarsawTPC - a time projection chamber.

![image.png](attachment:image.png)

This is how it looks in a real life:

![image.png](attachment:image.png)

Link to this notebook:

![image.png](attachment:image.png)
"""
