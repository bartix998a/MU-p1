# -*- coding: utf-8 -*-
"""MIM_project_2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ii89moG8kJDwrqWs1MDeMPMOJJvzw18W

## Workspace Setup
"""

# @title
import numpy as np
from scipy import signal
from typing import Literal
import random
import matplotlib.pyplot as plt

import os


def ground_truth_projection(x0, y0, x1, y1, bins):
    x_vals = np.linspace(min(x0, x1), max(x0, x1), bins)
    y_vals = np.linspace(min(y0, y1), max(y0, y1), bins)
    proj_x = np.histogram(x_vals, bins=bins, range=(0, bins))[0]
    proj_y = np.histogram(y_vals, bins=bins, range=(0, bins))[0]
    return proj_x, proj_y

# @title
projectionPhis = {
    "U": 0.0,
    "V": np.pi/6.0,
    "W": -np.pi/6.0
}



##############################################
##############################################
carbon_Bragg = np.loadtxt("./resources/dEdx_corr_12C_5MeV_CO2_250mbar.dat")
alpha_Bragg = np.loadtxt("./resources/dEdx_corr_alpha_10MeV_CO2_250mbar.dat")

##############################################
##############################################
def getLineIn3D(vertex=(0,0,0), carbonLength=5.0, alphaLength=40.0):

    angles = np.random.default_rng().uniform(0,1,(2))
    angles *= (2*np.pi, 2.0)
    angles += (0, -1)
    angles[1] = np.arccos(angles[1])

    rho = 1.0
    tangent = np.array([rho*np.sin(angles[1])*np.cos(angles[0]),
                        rho*np.sin(angles[1])*np.sin(angles[0]),
                        rho*np.cos(angles[1])])

    nPoints = 1024
    delta = np.linspace(-carbonLength,alphaLength,nPoints)
    delta = np.expand_dims(delta, axis=1)
    line = vertex + delta*tangent
    return line, tangent
##############################################
##############################################
def smearLine(line, sigma=1.0):

    noise = np.random.default_rng().normal(0,sigma,line.shape)
    noise[0,:] = 0.0 #do not smear endpoints to keep POIs exact for plotting
    noise[-1,:] = 0.0 #do not smear endpoints to keep POIs exact for plotting
    smearedLine = line + noise
    return smearedLine


##############################################
##############################################
def getXYZtoUVWT(data):

    referencePoint = np.array([-138.9971, 98.25]) # mm
    stripPitch = 1.5
    samplingFrequency = 25.0 # MHz
    driftVelocity = 6.46 # mm/us 4.05
    f = 1.0/samplingFrequency*driftVelocity
    triggerDelay = 5 #time bins
    u = -(data[:,1]-99.75) # change direction of the axis
    v = (data[:,0]-referencePoint[0])*np.cos(projectionPhis["V"]) - (data[:,1]-referencePoint[1])*np.sin(projectionPhis["V"]) + 98.75
    w = (data[:,0]-referencePoint[0])*np.cos(-projectionPhis["W"]) - (data[:,1]-referencePoint[1])*np.sin(-projectionPhis["W"]) + 98.75
    t = data[:,2]/f + 256 + triggerDelay
    u/=stripPitch
    v/=stripPitch
    w/=stripPitch

    return np.stack((u,v,w,t), axis=1)

##############################################
##############################################
def getSmearedBragg(curve, windowSize, sigma, lengthScale=1.0):

    window = signal.windows.gaussian(windowSize, std=sigma/lengthScale) #type:ignore
    window/=np.sum(window)
    curve_smeared = signal.convolve(curve[:,1], window, mode='full')
    x = np.arange(-windowSize/2, curve.shape[0]+windowSize/2-1)
    curve_smeared = np.stack((x*lengthScale, curve_smeared), axis=1)
    curve_smeared = curve_smeared[:-windowSize//2  :]
    return curve_smeared

##############################################
##############################################
def getBraggForTrack(trackData, vertex, sigma=2.0, windowSize=50):

    carbonTrackLength = np.sqrt(np.sum((trackData[0:1,:] - vertex)**2, axis=1))[0]
    carbon_Bragg_start = int(carbon_Bragg[-1,0] - carbonTrackLength)*4 # Carbon Bragg is sampled every 0.25 mm
    carbon_Bragg_smeared = getSmearedBragg(carbon_Bragg[carbon_Bragg_start:], windowSize, sigma, lengthScale=0.25)
    carbon_Bragg_smeared[:,0] *= -1
    indices = np.argsort(carbon_Bragg_smeared[:,0])
    carbon_Bragg_smeared = carbon_Bragg_smeared[indices]

    alphaTrackLength = np.sqrt(np.sum(([trackData[-1,:]] - vertex)**2, axis=1))[0]
    alpha_Bragg_start =  int(alpha_Bragg[-1,0]  - alphaTrackLength)  # Alpha Bragg is sampled every 1 mm
    alpha_Bragg_smeared = getSmearedBragg(alpha_Bragg[alpha_Bragg_start:], windowSize, sigma, lengthScale=1.0)

    #print("Total energy loss smeared (12C)   : {:.3f} MeV".format(np.sum(carbon_Bragg_smeared[:,1]*0.25)/1000.0))
    #print("Total energy loss smeared (alpha) : {:.3f} MeV".format(np.sum(alpha_Bragg_smeared[:,1]*1.0)/1000.0))

    carbon_Bragg_smeared[:,0] += carbonTrackLength
    alpha_Bragg_smeared[:,0] += carbonTrackLength

    step = 0.25
    x = np.arange(0, carbonTrackLength+alphaTrackLength+windowSize*step, step)
    y = np.interp(x, carbon_Bragg_smeared[:,0], carbon_Bragg_smeared[:,1], left=0, right=0) + np.interp(x, alpha_Bragg_smeared[:,0], alpha_Bragg_smeared[:,1], left=0, right=0) # type: ignore
    track_Bragg = np.stack((x, y), axis=1)

    return carbon_Bragg_smeared, alpha_Bragg_smeared, track_Bragg

##############################################
##############################################
def getNoiseUVWT(mu=0, sigma=20.):

    noisePoints = 1024
    noiseVal = np.random.default_rng().normal(mu,sigma,(noisePoints,3))
    noisePos = np.random.default_rng().uniform(0,256,(noisePoints,4))
    noisePos[:,3] *= 2

    return noisePos, noiseVal
##########################################################################
##########################################################################

def getBraggDensity(line, track_Bragg, sigma=2.0):

    x_along_line = np.sqrt(np.sum((line - line[0,:])**2, axis=1))
    x_along_line = np.where(x_along_line<len(track_Bragg), x_along_line,0)
    mu = np.interp( x_along_line, track_Bragg[:,0], track_Bragg[:,1], left=0, right=0 )

    density = np.random.default_rng().normal(mu, sigma)
    density = np.where(density>0, density, 0)
    density *= 50/np.max(density)
    return density
##############################################
##############################################

def getTestData(step :Literal['noise', 'fit', 'edges', 'middle', 'all'], sigma :float = 2.0, vertex = np.array((0,0,0))):
    carbonLength = 15.0
    alphaLength = 60.0
    lineXYZ, tangent = getLineIn3D(vertex, carbonLength, alphaLength)
    lineXYZ = smearLine(lineXYZ)
    lineUVWT = getXYZtoUVWT(lineXYZ)
    
    carbon_Bragg_smeared, alpha_Bragg_smeared, track_Bragg = getBraggForTrack(lineXYZ, vertex, sigma=sigma, windowSize=50)
    density = getBraggDensity(lineXYZ, track_Bragg, sigma=sigma)
    
    noiseUVWT, noiseVal = getNoiseUVWT(mu=0, sigma=15.0)
    lineUVWT_noise = np.concatenate((lineUVWT, noiseUVWT), axis=0)
    density_noise = np.concatenate((density, noiseVal[:,0]), axis=0)
    
    clear_histograms = np.stack(
        [np.histogram2d(lineUVWT[:,3], lineUVWT[:,i], bins=(512,256), range=[[0,512],[0,256]], weights=density)[0] for i in range(3)]
        , axis = 0)
    noise_histograms = np.stack(
        [np.histogram2d(lineUVWT_noise[:,3], lineUVWT_noise[:,i], bins=(512,256), range=[[0,512],[0,256]], weights=density_noise)[0] for i in range(3)]
        , axis = 0)
    
    if step == 'noise':
        return noise_histograms, clear_histograms
    elif step == 'fit':
        return clear_histograms, lineXYZ[0], lineXYZ[-1]
    elif step == 'edges':
        return clear_histograms, tangent, lineXYZ[random.randint(0, lineXYZ.shape[0] - 1)]
    elif step == 'all':
        return noise_histograms, lineXYZ[0], lineXYZ[-1], vertex
    else:
        return (clear_histograms, lineXYZ[0], lineXYZ[-1]), vertex




from reconstruction import reconstruct_line
from denoising import denoise_uwvt
from metrics import endpoint_error

def test_noise_accuracy(uwvt, gt_endpoints, denoiser):
  

    # --- raw reconstruction ---
    line_raw = reconstruct_line(uwvt)
    err_raw = endpoint_error(line_raw, gt_endpoints)

    # --- denoised reconstruction ---
    uwvt_clean = denoiser(uwvt)
    line_clean = reconstruct_line(uwvt_clean)
    err_clean = endpoint_error(line_clean, gt_endpoints)

    return {
        "raw_error": err_raw,
        "clean_error": err_clean,
        "improvement": err_raw - err_clean
    }

